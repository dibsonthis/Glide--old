ls = import["../../../dev_env/imports/list.gl"]
obj = import["../../../dev_env/imports/object.gl"]

get_type = [_object] => {
    _type = type[_object]

    if [_type == list] => {
        type_list = _object -> ls.map[[x] => { get_type[x] }] -> ls.unique -> ls.sort
        ret type_list
    }

    if [_type != object] => {
        ret _type
    }

    type_obj = @{}

    for [_object._keys index key] => {
        type_obj.[key] = get_type[_object.[key]]
    }

    ret type_obj
}

is_type = [_type value] => {
    calculated_type = type[value]
    if [calculated_type == object && type[_type] == object] => {
        ret (value -> get_type, _type) -> obj.equal
    }
    if [calculated_type == list] => {
        ret (value -> get_type, _type) -> ls.match
    }
    ret (calculated_type == _type)
}

func_t = [func _type args] => {

    name = shape[func].name
    func_args = shape[func].args
    func_params = shape[func].params

    arg_index = func_args.length

    if => {
        type[args] == comma_list: {
            for [args i arg] => {
                param_key = func_params.[i]
                if [!(arg -> is_type[_type.[param_key]])] => {
                    print[arg]
                    print["TypeError in function '" name "' - expected argument '" param_key "' in position " i " to be of type '" _type.[param_key] "' but received argument of type '" arg -> get_type "'\n"]
                    ret
                }
                func = arg -> func
            }
        }
        default: {
            param_key = func_params.[arg_index]
            if [!(args -> is_type[_type.[param_key]])] => {
                    print["TypeError in function '" name "' - expected argument '" param_key "' in position " arg_index " to be of type '" _type.[param_key] "' but received argument of type '" args -> get_type "'\n"]
                    ret
                }
            func = args -> func
        }
    }

    if [type[func] != function] => {

        if [_type.ret == empty] => {
            ret func
        }

        if [type[_type.ret] == comma_list] => {

            pass_check = false
            for [1..(_type.ret.length) i] => {
                if [func -> is_type[_type.ret.[i]]] => {
                    pass_check = true
                }
            }

            if [pass_check] => {
                ret func
            }

            print["TypeError in function '" name "' - expected return value to be of type '" _type.ret "' but returned value is of type '" func -> get_type "'\n"]
            ret
        }

        if [!(func -> is_type[_type.ret])] => {
            print["TypeError in function '" name "' - expected return value to be of type '" _type.ret "' but returned value is of type '" func -> get_type "'\n"]
            ret
        }

        ret func
    }

    ret func_t[var[name func] _type]
}

var_t = [value _type] => {

    typed_var = @{
        value: value
        type: _type
        eq = [new_val] => {
            t = import["imports/types.gl"]

            if [type[new_val] == int && this.type == float] => {
                this.value = new_val -> to_float
                ret this
            }

            if [type[new_val] == float && this.type == int] => {
                this.value = new_val -> to_int
                ret this
            }

            if [new_val -> t.is_type[this.type]] => {
                this.value = new_val
                ret this
            }

            print["TypeError - variable of type '" this.type "' cannot be assigned a value of type '" new_val -> t.get_type "'\n"]
        }
    }

    if [type[value] == int && _type == float] => {
        typed_var.value = value -> to_float
        ret typed_var
    }

    if [type[value] == float && _type == int] => {
        typed_var.value = value -> to_int
        ret typed_var
    }

    if [!(value -> is_type[_type])] => {
        print["TypeError - variable of type '" _type "' cannot be assigned a value of type '" value -> get_type "'\n"]
        ret
    }

    ret typed_var
}